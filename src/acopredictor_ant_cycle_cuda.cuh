#pragma once

#include <string>

#include "cuda_device_utilities.cuh"

/** Holds data needed by each CUDA thread to execute its work.
 * We associate __device__ functions with this structure, which makes access to this
 *   struct's data by a thread much easier.
 */
struct CUDAThread {
	int tid; /**< Unique identifier for the thread within all blocks (the grid). */
	int randNumber; /**< Random number that also serves as the seed for generation. */
	int3 *mySolution; /**< Memory region containing coordinates of the solution this
	                       thread is developing. */
	int3 *myOtherSolution; /**< Memory region that the thread uses for performing
	                            local seach (small perturbation) on mySolution. */
	char *myDirections; /**< Memory containing relative directions for mySolution. */
	char *myOtherDirections; /**< Memory containing relative directions for myOtherSolution. */
	double *pheromones; /**< Pointer to the pheromone matrix (shared by all threads). */
	char *hpChain; /**< hpChain of the protein being predicted (shared by all threads). */
	int nCoords; /**< Number of coordinates of the protein. */
	int nMovElems; /**< Number of directions of the protein. */
	double dAlpha; /**< Alpha parameter of the ACO algorithm. */
	double dBeta; /**< Beta parameter of the ACO algorithm. */

	/** Returns the vector obtained by following the vector 'prevDir' and turning to direction 'dir'. */
	static __device__ int3 DIRECTION_VECTOR(int3 prevDir, char dir);

	/** Given a vector of relative directions, returns a vector of coordinates generated by these directions.
	 * \param solution Memory region where we should store the resulting solution.
	 * \param directions Memory region containing the directions.
	 */
	__device__ void solution_from_directions(int3 *solution, char *directions);

	/** Performs local search in the thread's own solution, replacing `mySolution` if a better solution is found.
	 * \param solContact Output argument where we store the highest number of contacts found.
	 * \param lsFreq Local search frequency, which defines the number of perturbations to generate.
	 */
	__device__ void local_search(int &solContact, int lsFreq);

	/** Getter for individual pheromones.
	 * \param i The index of relative direction that is currently being decided.
	 * \param d The relative direction in [0-4] that is being considered.
	 */
	__device__ double &pheromone(int i, int d);

	/** Counts contacts within the given solution.
	 * \return Number of contacts within the given solution, or -1 if the solution is invalid,
	 *    that is, it contains a collision. */
	__device__ int calculate_contacts(int3 *solution);

	/** Calculates the heuristic value for the step being decided.
	 * \param curSize Number of __coordinates__ that have already been decided.
	 *    should correspond to the number of valid coordinates in the given `solution`.
	 * \param solution Memory region containing the coordinates being decided.
	 * \param heurs Output array of 5 doubles where we store heuristic values for each direction.
	 * \param possiblePos Array of the 5 possible positions that result by following each of the 5
	 *    directions in the current `solution`.
	 */
	__device__ void get_heuristics(int curSize, int3 *solution, double *heurs, int3 *possiblePos);

	/** Calculates probability of following each of the 5 directions.
	  * \param movIndex Index of the direction being decided.
	  * \param probs Output array with 5 doubles where we store the probability of following
	  *   each of the 5 directions.
	  * \param heurs Array with the 5 heuristic values of each possible direction.
	  */
	__device__ void get_probabilities(int movIndex, double *probs, double *heurs);

	/** Simulates the behavior of an ant walking through the pheromone matrix,
	  *   developing a solution.
	  * \param solution Output memory region in which to store the solution coordinates.
	  * \param directions Output memory region in which to store the solution directions.
	  */
	__device__ void develop_solution(int3 *solution, char *directions);
};

namespace HostToDevice {
	__global__
	void ant_develop_solution(
		double *pheromone,   int nMovElems,
		int3 *solutions,     int3 *moreSolutions, int nCoords,
		char *relDirections, char *moreRelDirections,
		int *contacts,       char *hpChain,       int lsFreq,
		double alpha,        double beta
	);

	__global__
	void find_best_solution(
		int *contacts,       int nContacts,
		char *directions,    int nMovElems,
		char *outDirections, int *outBestContact
	);

	__global__
	void evaporate_pheromones(double *pheromones, int nMovElems, double evapRate);

	__global__
	void deposit_pheromones(double *pheromones, int nMovElems, char *directions, int *contacts, int hCount);
}

struct ACODeviceData {
	CUDAPointer<double> pheromone;
	CUDAPointer<int3>   solutions;
	CUDAPointer<int3>   moreSolutions;
	CUDAPointer<char>   relDirections;
	CUDAPointer<char>   moreRelDirections;
	CUDAPointer<int>    contacts;
	CUDAPointer<int>    bestContact;
	CUDAPointer<char>   hpChain;
};
