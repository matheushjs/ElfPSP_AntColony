#pragma once

#include <string>

#include "cuda_device_utilities.cuh"

/** Holds data needed by each CUDA thread to execute its work.
 * We associate __device__ functions with this structure, which makes access to this
 *   struct's data by a thread much easier.
 */
struct CUDAThread {
	int tid; /**< Unique identifier for the thread within all blocks (the grid). */
	int randNumber; /**< Random number that also serves as the seed for generation. */
	int3 *mySolution; /**< Memory region containing coordinates of the solution this
	                       thread is developing. */
	int3 *myOtherSolution; /**< Memory region that the thread uses for performing
	                            local seach (small perturbation) on mySolution. */
	char *myDirections; /**< Memory containing relative directions for mySolution. */
	char *myOtherDirections; /**< Memory containing relative directions for myOtherSolution. */
	double *pheromones; /**< Pointer to the pheromone matrix (shared by all threads). */
	char *hpChain; /**< hpChain of the protein being predicted (shared by all threads). */
	int nCoords; /**< Number of coordinates of the protein. */
	int nMovElems; /**< Number of directions of the protein. */
	double dAlpha; /**< Alpha parameter of the ACO algorithm. */
	double dBeta; /**< Beta parameter of the ACO algorithm. */

	/** Returns the vector obtained by following the vector 'prevDir' and turning to direction 'dir'. */
	static __device__ int3 DIRECTION_VECTOR(int3 prevDir, char dir);

	/** Given a vector of relative directions, returns a vector of coordinates generated by these directions.
	 * \param solution Memory region where we should store the resulting solution.
	 * \param directions Memory region containing the directions.
	 */
	__device__ void solution_from_directions(int3 *solution, char *directions);

	/** Performs local search in the thread's own solution, replacing `mySolution` if a better solution is found.
	 * \param[out] solContact Output argument where we store the highest number of contacts found.
	 * \param lsFreq Local search frequency, which defines the number of perturbations to generate.
	 */
	__device__ void local_search(int &solContact, int lsFreq);

	/** Getter for individual pheromones.
	 * \param i The index of relative direction that is currently being decided.
	 * \param d The relative direction in [0-4] that is being considered.
	 */
	__device__ double &pheromone(int i, int d);

	/** Counts contacts within the given solution.
	 * \return Number of contacts within the given solution, or -1 if the solution is invalid,
	 *    that is, it contains a collision. */
	__device__ int calculate_contacts(int3 *solution);

	/** Calculates the heuristic value for the step being decided.
	 * \param curSize Number of __coordinates__ that have already been decided.
	 *    should correspond to the number of valid coordinates in the given `solution`.
	 * \param solution Memory region containing the coordinates being decided.
	 * \param[out] heurs Output array of 5 doubles where we store heuristic values for each direction.
	 * \param possiblePos Array of the 5 possible positions that result by following each of the 5
	 *    directions in the current `solution`.
	 */
	__device__ void get_heuristics(int curSize, int3 *solution, double *heurs, int3 *possiblePos);

	/** Calculates probability of following each of the 5 directions.
	  * \param movIndex Index of the direction being decided.
	  * \param[out] probs Output array with 5 doubles where we store the probability of following
	  *   each of the 5 directions.
	  * \param heurs Array with the 5 heuristic values of each possible direction.
	  */
	__device__ void get_probabilities(int movIndex, double *probs, double *heurs);

	/** Simulates the behavior of an ant walking through the pheromone matrix,
	  *   developing a solution.
	  * \param[out] solution Output memory region in which to store the solution coordinates.
	  * \param[out] directions Output memory region in which to store the solution directions.
	  */
	__device__ void develop_solution(int3 *solution, char *directions);
};


/** \defgroup CudaModules
 *  \{ */
/** Contains functions that are called in the host, but executed in the device. */
namespace HostToDevice {
	/** Launches threads such that each thread executes the work of an ant.
	 * An ant develops a solution by deciding relative directions, using the pheromone
	 *   matrix as a guide.
	 * The ant is also in charge of performing local search by generating small perturbations
	 *   on the developed protein, and checking if the perturbed one is better.
	 *
	 * \param pheromone Matrix of pheromones.
	 * \param nMovElems Number of relative movements per protein conformation (probably equal
	 *                    the number of aminoacids minus 2).
	 * \param solutions Memory region that can hold all protein solutions of all threads.
	 * \param moreSolutions Memory region with same size as `solutions`.
	 *                      Will be used as temporary storage.
	 * \param nCoords Number of coordinates that a protein has (probably equal the
	 *                number of aminoacids).
	 * \param relDirections Memory region that can hold all arrays of relative directions,
	 *                        one for each launched thread.
	 * \param moreRelDirections Memory region with same size as `relDirections`.
	 *                          Will be used as temporary storage.
	 * \param[out] contacts Memory region to which we can store the number of contacts for each
	 *                      protein developed by each thread.
	 * \param hpChain The HP chain of the protein being predicted.
	 * \param lsFreq Local Search Frequency, determines the number of protein perturbations to
	 *               generate after the ant develops the first protein using the pheromones.
	 * \param alpha Alpha parameter of the ACO algorithm.
	 * \param beta Beta parameter of the ACO algortihm.
	 */
	__global__
	void ant_develop_solution(
		double *pheromone,   int nMovElems,
		int3 *solutions,     int3 *moreSolutions, int nCoords,
		char *relDirections, char *moreRelDirections,
		int *contacts,       char *hpChain,       int lsFreq,
		double alpha,        double beta
	);

	/** Finds the best solution among those produced by `ant_develop_solution`.
	  * \param contacts Array of contacts produced by `ant_develop_solution`.
	  * \param nContacts number of contacts in `contacts`.
	  * \param directions Array containing relative directions for all proteins produced by
	  *                   `ant_develop_solution`.
	  * \param nMovElems Number of relative directions per protein.
	  * \param[out] outDirections Memory region where we can store the relative directions
	  *                           of the best protein identified.
	  * \param[out] outBestContact Memory region (an integer) to which we can store the number
	  *                            of contacts of the best protein identified.
	  */
	__global__
	void find_best_solution(
		int *contacts,       int nContacts,
		char *directions,    int nMovElems,
		char *outDirections, int *outBestContact
	);

	/** Evaporates pheromones in the pheromone matrix.
	  * \param[in,out] pheromones Pheromone matrix.
	  * \param nMovElems Number of relative directions per protein.
	  * \param evapRate Rate of evaporation of pheromones. Each pheromone is multiplied
	  *                 by (1-evapRate).
	  */
	__global__
	void evaporate_pheromones(double *pheromones, int nMovElems, double evapRate);

	/** Deposits pheromones in the pheromone matrix, according the each protein's quality.
	  * \param pheromones Pheromone matrix.
	  * \param nMovElems Number of relative directions per protein.
	  * \param directions Array containing relative directions for all proteins produced by
	  *                   `ant_develop_solution`.
	  * \param contacts Array of contacts produced by `ant_develop_solution`.
	  * \param hCount Number of H beads within the HP chain of the protein being predicted.
	  */
	__global__
	void deposit_pheromones(double *pheromones, int nMovElems, char *directions, int *contacts, int hCount);
}
/** \} */

struct ACODeviceData {
	CUDAPointer<double> pheromone;
	CUDAPointer<int3>   solutions;
	CUDAPointer<int3>   moreSolutions;
	CUDAPointer<char>   relDirections;
	CUDAPointer<char>   moreRelDirections;
	CUDAPointer<int>    contacts;
	CUDAPointer<int>    bestContact;
	CUDAPointer<char>   hpChain;
};
